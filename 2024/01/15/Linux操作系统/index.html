<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icons8-%E6%BA%90%E4%BB%A3%E7%A0%81-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icons8-%E6%BA%90%E4%BB%A3%E7%A0%81-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Operating System Lecture Notes">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="doovvv">
<meta property="og:description" content="Operating System Lecture Notes">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-17-16-13-35.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-16-16-11-53.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-16-16-33-57.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-16-16-56-24.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-19-13-19-11.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-23-16-00-10.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-01-11-40-43.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-01-16-52-41.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-01-16-53-15.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-01-16-55-28.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-05-11-51-53.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-15-00-50-46.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-12-20-36-44.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-15-00-26-42.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-15-01-01-36.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/38dfa717356a085b5eff1dcaf4bfe39.jpg">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-06-10-42-00.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-06-17-27-17.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-06-17-32-55.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-00-22-09.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-10-14-23.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-10-23-13.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-10-27-29.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-10-48-22.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-18-08-50-05.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-18-09-13-51.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-10-53-24.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-15-54-11.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-15-49-02.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-15-59-14.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-20-16-04.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-20-19-48.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-20-24-59.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-20-53-22.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/de970afca866dea878ad543e12f58c4.jpg">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-10-21-58.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-10-37-39.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-10-43-19.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-10-49-50.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-11-01-09.png">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2ba0fe81d0d2031fac8d7306da71a39.jpg">
<meta property="og:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-11-31-11.png">
<meta property="article:published_time" content="2024-01-15T11:43:04.000Z">
<meta property="article:modified_time" content="2024-07-01T12:44:18.017Z">
<meta property="article:author" content="doovvv">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-17-16-13-35.png">

<link rel="canonical" href="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>操作系统 | doovvv</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">doovvv</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="doovvv">
      <meta itemprop="description" content="一切都没有意外，只是多了些波折">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="doovvv">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-15 19:43:04" itemprop="dateCreated datePublished" datetime="2024-01-15T19:43:04+08:00">2024-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-07-01 20:44:18" itemprop="dateModified" datetime="2024-07-01T20:44:18+08:00">2024-07-01</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Operating System Lecture Notes<br><span id="more"></span></p>
<h1 id="Operating-system-Structure"><a href="#Operating-system-Structure" class="headerlink" title="Operating-system Structure"></a>Operating-system Structure</h1><h2 id="操作系统结构分类"><a href="#操作系统结构分类" class="headerlink" title="操作系统结构分类"></a>操作系统结构分类</h2><ul>
<li>分层法：<ul>
<li>便于调试和验证（+）</li>
<li>易扩展和维护（+）只要不改变接口，可修改或替换某层</li>
<li>合理定义各层比较困难（-）</li>
<li>效率较差（-）层间通信增加额外开销</li>
</ul>
</li>
<li>模块化：<ul>
<li>提高了操作系统设计的正确性、可理解性和可维护性（+）</li>
<li>增强了操作系统的可适应性（+）</li>
<li>加速了操作系统开发过程（+）</li>
<li>模块间的接口规定很难满足对接口的实际需求（-）</li>
<li>各模块设计者齐头并进，无法找到一个可靠的决定顺序（-）</li>
</ul>
</li>
<li>宏内核：是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态  </li>
<li>微内核：机制与策略分离，C/S模式（客户和服务器之间借助微内核提供的消息传递机制来通信）<ul>
<li>通常包含的功能：<ul>
<li>进程（线程管理）</li>
<li>低级存储器管理（地址转换-&gt;硬件）</li>
<li>中断和陷入处理</li>
</ul>
</li>
<li>可扩展性和灵活性</li>
<li>可靠性和安全性</li>
<li>可移植性</li>
<li>分布式计算</li>
<li>开销更大，因为需要频繁的切换用户态和核心态（-）</li>
</ul>
</li>
<li>外核<h2 id="两个接口："><a href="#两个接口：" class="headerlink" title="两个接口："></a>两个接口：</h2></li>
<li>users:  <ul>
<li>CLI 通过终端向操作系统发布指令-&gt;联机命令接口</li>
<li>GUI 图形化</li>
<li>Batch 批处理-&gt;脱机命令接口</li>
</ul>
</li>
<li>apps:  <ul>
<li>API -&gt; system call(OS level code -&gt; kernel mode)</li>
<li>trap mechamism -&gt; dual mode(user mode / kernel mode)  </li>
</ul>
</li>
</ul>
<h2 id="dual-mode（用一个硬件模式位来表示当前模式位）："><a href="#dual-mode（用一个硬件模式位来表示当前模式位）：" class="headerlink" title="dual mode（用一个硬件模式位来表示当前模式位）："></a>dual mode（用一个硬件模式位来表示当前模式位）：</h2><ul>
<li>user mode：用户级的代码</li>
<li>kernel mode：操作系统级的代码</li>
</ul>
<h2 id="系统调用实现机制："><a href="#系统调用实现机制：" class="headerlink" title="系统调用实现机制："></a>系统调用实现机制：</h2><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-17-16-13-35.png" alt></p>
<h2 id="Process-Concept"><a href="#Process-Concept" class="headerlink" title="Process Concept"></a>Process Concept</h2><h2 id="进程的定义："><a href="#进程的定义：" class="headerlink" title="进程的定义："></a>进程的定义：</h2><ul>
<li>进程时一个程序的一次执行过程：  <ul>
<li>能完成具体的功能（一系列指令）</li>
<li>是在某个数据集合上完成的（data，堆栈）</li>
<li>执行过程是可并发的</li>
</ul>
</li>
<li>进程是资源分配、保护和调度的基本单位</li>
</ul>
<ul>
<li>程序：被动的，一个包含指令的存在磁盘上的可执行文件</li>
<li>进程：活动的，当程序被加载进内存，就是进程（包含一个PC）  </li>
</ul>
<h2 id="Process-in-Memory"><a href="#Process-in-Memory" class="headerlink" title="Process in Memory:"></a>Process in Memory:</h2><p>回忆在计组课程中写MIPS代码时，就区分了data区和text区<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-16-16-11-53.png" alt><br>text区域存放指令（read only）<br>data区域直到程序结束才会回收  </p>
<h2 id="并发和并行："><a href="#并发和并行：" class="headerlink" title="并发和并行："></a>并发和并行：</h2><p>并发Concurrency：多个事件同时发生或存在（单核CPU）<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-16-16-33-57.png" alt><br>并行：同时运行</p>
<h2 id="Process-State："><a href="#Process-State：" class="headerlink" title="Process State："></a>Process State：</h2><ul>
<li>Running运行态：此时进程的代码在CPU上运行（单核CPU系统中只能有一个进程处于运行态，但不一定会有一个进程处于运行态，当所有进程都发生死锁时，所有进程都会处于阻塞态）  </li>
<li>Ready就绪态：进程具备运行条件，等待分配CPU</li>
<li>Waiting等待态(阻塞态）：进程在等待某些事件的发生（比如IO操作结束）  </li>
</ul>
<h2 id="进程切换："><a href="#进程切换：" class="headerlink" title="进程切换："></a>进程切换：</h2><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-16-16-56-24.png" alt><br>一些例子：<br>运行态-&gt;就绪态：时间片用完，被高优先级进程抢占<br>运行态-&gt;阻塞态：申请临界资源，从磁盘读数据</p>
<h1 id="Process-Scheduling"><a href="#Process-Scheduling" class="headerlink" title="Process Scheduling"></a>Process Scheduling</h1><h2 id="中断技术"><a href="#中断技术" class="headerlink" title="中断技术"></a>中断技术</h2><p> <img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-19-13-19-11.png" alt><br> 系统调用时中断的一个特例</p>
<h2 id="中断源："><a href="#中断源：" class="headerlink" title="中断源："></a>中断源：</h2><ul>
<li>外中断（中断Interrupt）：  <ul>
<li>处理器之外的信号</li>
<li>外部中断均是异步中断</li>
</ul>
</li>
<li>内中断（异常Exception）：  <ul>
<li>处理器内部的信号</li>
<li>硬件异常：掉电，奇偶检验</li>
<li>程序异常：越界，除0</li>
<li>系统调用<h2 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h2>每个中断源都有对应的处理程序，这个处理程序称为中断服务程序，其入口地址称为中断向量。所有中断的中断服务程序的入口地址构成一个表，称为中断向量表。<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2>特权指令：只能运行在内核模式下运行的指令<br>非特权指令：只能运行在用户模式下运行的指令</li>
</ul>
</li>
</ul>
<h2 id="模式切换："><a href="#模式切换：" class="headerlink" title="模式切换："></a>模式切换：</h2><p>中断时用户态向核心态转换的唯一途径。由硬件完成。</p>
<h2 id="进程切换：-1"><a href="#进程切换：-1" class="headerlink" title="进程切换："></a>进程切换：</h2><ul>
<li>切换时机：<ul>
<li>主动进入等待状态</li>
<li>被动进入就绪状态</li>
</ul>
</li>
<li>切换过程<ul>
<li>保存中断进程的上下文信息</li>
<li>保存被中断进程的控制信息</li>
<li>将被中断的进程加入相应的序列</li>
<li>调度一个新的进程并恢复它的上下文信息</li>
</ul>
</li>
</ul>
<h2 id="进程控制块（状态）PCB"><a href="#进程控制块（状态）PCB" class="headerlink" title="进程控制块（状态）PCB"></a>进程控制块（状态）PCB</h2><p>被中断的进程的状态数据存在PCB<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-01-23-16-00-10.png" alt></p>
<h2 id="进程队列："><a href="#进程队列：" class="headerlink" title="进程队列："></a>进程队列：</h2><p>只把PCB放入队列，而不是整个进程上下文  </p>
<h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>高级通信：</p>
<ul>
<li>共享存储</li>
<li>消息传递</li>
<li>管道通信：<ul>
<li>管道是一个固定大小的缓冲区</li>
<li>管道为空时，read()操作默认被阻塞</li>
</ul>
</li>
</ul>
<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="线程的定义："><a href="#线程的定义：" class="headerlink" title="线程的定义："></a>线程的定义：</h2><p>线程是CPU利用的基本单元，线程包含一个线程id，PC，寄存器，栈。它和其他属于统一进程的线程共享code，data和其他操作系统资源（它没有自己独立的地址空间）。<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-01-11-40-43.png" alt></p>
<h2 id="多线程模型："><a href="#多线程模型：" class="headerlink" title="多线程模型："></a>多线程模型：</h2><p>在多处理器系统当中，多核编程机制让应用程序可以让并发的线程分散到不同的处理器运行，以实现并行计算。</p>
<ul>
<li>用户线程ULT：ULT在user mode下运行，它的管理无需内核支持</li>
<li>内核线程KLT：KLT在kernel mode下运行，由操作系统支持与管理，只有内核级线程才是处理及分配的单位。操作系统感受不到用户线程的存在</li>
</ul>
<p>M:1模型：<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-01-16-52-41.png" alt><br>1：1模型（主流）：<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-01-16-53-15.png" alt><br>M：M模型：<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-01-16-55-28.png" alt></p>
<p>线程库：为程序员提供创建和管理线程的API  </p>
<h1 id="CPU-Scheduleing"><a href="#CPU-Scheduleing" class="headerlink" title="CPU Scheduleing"></a>CPU Scheduleing</h1><h2 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h2><p>当CPU空闲时，操作系统选择一个在就绪队列的进程执行  </p>
<p>抢占调度：</p>
<ul>
<li>非抢占调度：一旦进程得到CPU，就会一直用到终止或者等待状态（主动）</li>
<li>抢占调度：除此之外，都是抢占调度</li>
</ul>
<h2 id="CPU调度准则"><a href="#CPU调度准则" class="headerlink" title="CPU调度准则"></a>CPU调度准则</h2><p>调度算法性能的衡量：<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-05-11-51-53.png" alt>  </p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>先来先服务（FCFS/FIFO）：  </p>
<ul>
<li>非抢占式调度算法</li>
<li>简单易行（+）</li>
<li>如果短作业处于长作业的后面将导致周转时间变长（-）</li>
<li>有利于CPU繁忙型作业，不利于I/O繁忙型作业</li>
</ul>
<p>时间片轮转(RR)：</p>
<ul>
<li>每个进程都可以得到相同的CPU时间，当时间片到达，进程被剥夺CPU并加入就绪队列的尾部</li>
<li>抢占式调度算法</li>
<li>时间片选取：<ul>
<li>取值太小：进程切换开销显著增大（不能小于进程切换的时间）</li>
<li>取值太大：响应速度下降（时间片无穷大就退化成先来先服务）</li>
</ul>
</li>
<li>公平算法（+）</li>
<li>对长作业带来额外开销（-）</li>
<li>适合实现人机交互</li>
</ul>
<p>最短作业优先（SJF）：</p>
<ul>
<li>下一次调度总是选择需要CPU时间最短的那个作业</li>
<li>饥饿现象：长进程长时间得不到CPU</li>
<li>预测技术：预测一个进程的CPU时间并非易事</li>
<li>优化了响应时间（+）</li>
<li>难以预测CPU时间（-）</li>
<li>不公平算法（-）</li>
</ul>
<p>优先级调度：</p>
<ul>
<li>下一次调度总是选择优先级高的调度</li>
<li>静态优先级：优先级保持不变，但是可能会出现饥饿现象</li>
<li>动态优先级：<ul>
<li>根据进程占用CPU时间：当进程占用CPU时间越长，优先级逐渐降低</li>
<li>根据进程等待CPU时间：当进程在就绪队列中的等待时间越长，优先级逐渐升高</li>
</ul>
</li>
</ul>
<p>多级反馈队列调度算法：</p>
<ul>
<li>是时间片轮转调度算法和优先级调度算法的综合与发展</li>
<li>算法思想：<ul>
<li>设置多个就绪队列，每个就绪队列的优先级逐渐降低</li>
<li>赋予各个队列的进程运行时间片的大小各不相同，优先级越高时间片越小</li>
<li>每个队列都采用FCFS</li>
<li>按照优先级调度。只有第一级队列为空时，才会调度第二级队列</li>
</ul>
</li>
<li>终端型用户：短作业优先</li>
<li>短批处理用户：周转时间较少</li>
<li>长批处理用户：经过前面几个队列</li>
</ul>
<p>高响应比优先调度：</p>
<ul>
<li>同时考虑了等待时间和执行时间<blockquote>
<p><strong>没有最好最坏的策略，只有最合适的场景</strong>  </p>
</blockquote>
</li>
</ul>
<h1 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发进程/线程之间是交替进行的。  </p>
<p>并发进程之间的关系：</p>
<ul>
<li>独立关系</li>
<li>交互关系：并发进程执行过程中需要共享或交换数据<ul>
<li>竞争 -&gt; 互斥锁（互斥关系）</li>
<li>协作 -&gt; 信号量（同步关系）<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-15-00-50-46.png" alt></li>
</ul>
</li>
</ul>
<h2 id="异步引发的异常"><a href="#异步引发的异常" class="headerlink" title="异步引发的异常"></a>异步引发的异常</h2><p>会引发<strong>竞争条件</strong>：多个进程并发操作于同一个数据导致执行结果依赖于特定的执行顺序</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>进程同步是一种用于维护共享在交互进程的数据一致性的机制</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<p>管程有三部分组成：</p>
<ul>
<li>局部于管程的共享变量说明</li>
<li>对数据结构进行操作的一组过程</li>
<li>对局部于管程的数据设置初始值的语句。此外，还需为管程赋予一个名字。</li>
</ul>
<p>管程的引入是为了解决临界区分散所带来的管理和控制问题。</p>
<h1 id="Mutex-Locks"><a href="#Mutex-Locks" class="headerlink" title="Mutex Locks"></a>Mutex Locks</h1><h2 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h2><p>并发进程中改变公共数据区域的代码被称作临界区。临界区中不允许有两个进程同时执行。<br>临界区问题就是设计协议使得进程之间能过协作。</p>
<h2 id="临界区管理规则"><a href="#临界区管理规则" class="headerlink" title="临界区管理规则"></a>临界区管理规则</h2><ul>
<li>有空让进</li>
<li>择一而入</li>
<li>无空等待</li>
<li>有限等待</li>
<li>让权等待  </li>
</ul>
<h2 id="软件解决临界区管理"><a href="#软件解决临界区管理" class="headerlink" title="软件解决临界区管理"></a>软件解决临界区管理</h2><p>两个进程的实现代码是不对称的，当进程数量超过两个时，编程变得复杂</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>锁的基本操作：<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-12-20-36-44.png" alt>  </p>
<p>原子操作：<br>原子操作在运行时不能被操作</p>
<p>锁的实现：<br>使用了原语test_and_set<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-15-00-26-42.png" alt>  </p>
<p>忙式等待：<br>占用CPU执行空循环实现等待（自旋锁）</p>
<ul>
<li>浪费CPU周期（-）</li>
<li>进程在等待时没有上下文切换（+）  </li>
</ul>
<h1 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h1><p>信号量是一种比互斥锁更强大的同步工具。<br>信号量是一个整形变量，除了初始化之外，信号量只能被P和V两种原子操作access。  </p>
<h2 id="信号量的实现："><a href="#信号量的实现：" class="headerlink" title="信号量的实现："></a>信号量的实现：</h2><ul>
<li><p>P操作：信号量&lt;=0则执行忙式等待;否则信号量减1.</p>
</li>
<li><p>V操作：将信号量减1.</p>
</li>
</ul>
<h3 id="整数型信号量"><a href="#整数型信号量" class="headerlink" title="整数型信号量"></a>整数型信号量</h3><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-02-15-01-01-36.png" alt></p>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/38dfa717356a085b5eff1dcaf4bfe39.jpg" alt="38dfa717356a085b5eff1dcaf4bfe39">  </p>
<h2 id="信号量的使用："><a href="#信号量的使用：" class="headerlink" title="信号量的使用："></a>信号量的使用：</h2><ul>
<li>二值信号量：二值信号量值只能是0或1，通常初始化为1，用于实现互斥锁的功能（P、V操作都是原子操作）。  </li>
<li>一般信号量的取值可以是任意值，用于控制并发进程对共享资源的访问。  </li>
<li>P、V操作必须同时出现。  </li>
<li>信号量—》可用资源数量：<ul>
<li>s = 1-&gt;竞争</li>
<li>s &gt; 1-&gt;可用资源 </li>
<li>s = 0-&gt;用于进程同步</li>
</ul>
</li>
</ul>
<h2 id="信号量实现同步问题："><a href="#信号量实现同步问题：" class="headerlink" title="信号量实现同步问题："></a>信号量实现同步问题：</h2><p>同步问题的实质是将异步的并发进程按照某种顺序执行。<br>解决同步问题的本质就是找到并发进程的交互点。  </p>
<h1 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>处于等待状态的进程所需的资源被另外的处于等待状态的进程占有，这种情况就叫死锁</p>
<h2 id="哲学家用餐死锁问题"><a href="#哲学家用餐死锁问题" class="headerlink" title="哲学家用餐死锁问题"></a>哲学家用餐死锁问题</h2><p>解决办法：</p>
<ul>
<li>至多允许同时四个哲学家吃</li>
<li>奇数号哲学家先取左边筷子，偶数号哲学家先取右边筷子</li>
<li>每个哲学家必须拿到两个筷子，否则不拿  </li>
</ul>
<h2 id="饥饿-vs-死锁"><a href="#饥饿-vs-死锁" class="headerlink" title="饥饿 vs 死锁"></a>饥饿 vs 死锁</h2><p>饥饿：进程长时间等待<br>死锁：循环等待资源<br>死锁=&gt;饥饿（反之不亦然）：</p>
<ul>
<li>饥饿可能终止</li>
<li>如果无外部干涉，死锁不会终止</li>
</ul>
<h2 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h2><ul>
<li><strong>互斥使用</strong>：同一时刻，一个资源仅能被一个进程使用</li>
<li><strong>不可剥夺</strong>：进程间不能剥夺彼此的资源</li>
<li><strong>占有和等待</strong>（请求并保持）：进程资源得不到满足时，不会释放资源</li>
<li><strong>循环等待</strong>：存在一个闭合的进程链，每个进程至少拥有链中下一个进程的一个资源</li>
</ul>
<h2 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h2><ul>
<li>预防：破坏四个必要条件<ul>
<li>破坏互斥条件：通常不可行，并且需要保护互斥条件</li>
<li>破坏不剥夺条件：常用于状态易保存和恢复的资源，如CPU内存资源和寄存器，一般不能用于打印机等资源</li>
<li>破坏请求并保持条件：预先静态分配法，即在运行前就一次申请完它需要的全部资源。<ul>
<li>缺点：资源浪费，还可能导致饥饿现象</li>
</ul>
</li>
<li>破坏循环等待条件：顺序资源分配法<ul>
<li>缺点：限制了新设备的增加</li>
</ul>
</li>
</ul>
</li>
<li>避免：属于预防策略<ul>
<li>系统安全状态：在进行资源分配时，应先计算此次分配的安全性，若此次分配不会导致不安全状态，则允许分配，否则让进程等待。</li>
<li>银行家算法：进程运行前声明对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量，若没超过再进行系统安全状态的检测。</li>
</ul>
</li>
</ul>
<h2 id="死锁的检测和接触"><a href="#死锁的检测和接触" class="headerlink" title="死锁的检测和接触"></a>死锁的检测和接触</h2><ul>
<li>死锁检测时机：<ul>
<li>当进程等待时检测死锁</li>
<li>定时检测</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
</li>
<li>死锁的检测：<ul>
<li>资源分配图</li>
<li>死锁定理：S死锁的条件是当且仅当S的资源分配图是不可完全简化的</li>
</ul>
</li>
<li>死锁的解除：<ul>
<li>资源剥夺法</li>
<li>撤销进程法</li>
<li>进程回退法</li>
</ul>
</li>
</ul>
<h1 id="Memory-Mangement"><a href="#Memory-Mangement" class="headerlink" title="Memory Mangement"></a>Memory Mangement</h1><h2 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h2><p>程序的链接：</p>
<ul>
<li>静态链接</li>
<li>装入时动态链接：边装入边链接</li>
<li>运行时动态链接：对某些模块的链接，在程序执行中需要该模块才进行链接。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块。</li>
</ul>
<p>程序的装入：</p>
<ul>
<li>绝对装入：内存的装入方式只适用于单道程序设计环境。在编译时，编译程序将产生绝对地址的代码。</li>
<li>可重定位装入：程序中的地址都为相对地址，装入程序根据内存情况将装入模块装入到合适位置。在装入时对目标程序中的地址变换是一次完成的，所以又称为静态重定位。</li>
<li>动态运行时装入：不立即把装入模块的相对地址装换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。（适合程序要在内存中变化的程序）</li>
</ul>
<h2 id="内存管理目标"><a href="#内存管理目标" class="headerlink" title="内存管理目标"></a>内存管理目标</h2><ul>
<li>速度：cache</li>
<li>保护os：防止用户进程去读取os内存空间</li>
<li>保护用户进程（内存保护）：用户进程不能随意访问其他进程的空间</li>
<li>操作正确：地址转换、内存分配、内存回收<h2 id="Main-Memory"><a href="#Main-Memory" class="headerlink" title="Main Memory"></a>Main Memory</h2>CPU根据PC的值从内存中获取指令。<br>指令执行周期：fetch-&gt;decoded-&gt;execute-&gt;memmory-&gt;back</li>
</ul>
<h2 id="保护操作系统和用户进程"><a href="#保护操作系统和用户进程" class="headerlink" title="保护操作系统和用户进程"></a>保护操作系统和用户进程</h2><p>用户进程不可访问操作系统的内存数据，以及用户进程之间不能相互影响。<br>通过硬件实现：</p>
<ul>
<li>base register</li>
<li>limit register</li>
</ul>
<p>两个寄存器的值只能由特权指令获得</p>
<h2 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h2><ul>
<li>逻辑地址：面向程序的地址，总是从0开始编址，每一条指令的逻辑地址都是与第一条地址的相对偏移  </li>
<li>物理地址：内存单元看到的实际地址，也称为绝对地址</li>
</ul>
<h2 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h2><p>完成逻辑地址到物理地址（运行时）的转换工作：</p>
<ul>
<li>基址寄存器  </li>
</ul>
<h2 id="Contiguous-Memory-Allocation"><a href="#Contiguous-Memory-Allocation" class="headerlink" title="Contiguous Memory Allocation"></a>Contiguous Memory Allocation</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分，在用户区中，仅有一道用户程序。</p>
<h3 id="Fixed-Sized-Partition"><a href="#Fixed-Sized-Partition" class="headerlink" title="Fixed-Sized Partition"></a>Fixed-Sized Partition</h3><p>内存被分成几个固定大小的分区（每个分区的大小可能不同）<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-06-10-42-00.png" alt>  </p>
<ul>
<li>许多碎片，造成资源浪费（-）</li>
<li>内存回收：occupied修改为0</li>
</ul>
<h3 id="Variable-Partition"><a href="#Variable-Partition" class="headerlink" title="Variable Partition"></a>Variable Partition</h3><p>操作系统维护两张表，表明哪部分内存是可用的和哪部分是被占用的<br>动态存储分配问题：</p>
<ul>
<li>首次适应：分配首个足够大的孔，不需要遍历整个表，但是最佳适应和最坏适应需要，效率最高，空间利用率较低。</li>
<li>邻接适应：又称循环首次适应，分配内存时从上次查找结束的位置开始继续查找。</li>
<li>最佳适应：分配最小的孔。以容量递增链接。最容易产生碎片（由于每次选用当前大小要求最接近的空闲分区，然而大多数情况下空闲分区都会略大一点，这会导致产生碎片）</li>
<li>最坏适应：分配最大的孔，产生剩余孔，再次利用。空闲分区以容量递减链接，找到的第一个即为最大的。</li>
</ul>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>很小的内存块，很难被利用</p>
<ul>
<li>内部碎片（进程块内）</li>
<li>外部碎片（就可变分区而言，孔变得很小时就很难被利用）：  <ul>
<li>紧凑技术：<ul>
<li>静态时地址转换不能使用紧凑技术（编译时）</li>
<li>开销  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Segmenting-and-Paging"><a href="#Segmenting-and-Paging" class="headerlink" title="Segmenting and Paging"></a>Segmenting and Paging</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>一种应对碎片的方法：允许进程的逻辑地址不连续</p>
<h2 id="分段（基本分段管理方式）"><a href="#分段（基本分段管理方式）" class="headerlink" title="分段（基本分段管理方式）"></a>分段（基本分段管理方式）</h2><p>分段：</p>
<p>程序员认为程序是由若干大小不等的段构成的，如各种函数，数据结构，每个段都有专门的用途。这些段就可以存在内存中不连续的位置  </p>
<h3 id="分段硬件"><a href="#分段硬件" class="headerlink" title="分段硬件"></a>分段硬件</h3><p>逻辑地址：段号：段内偏移<br>段表：段标号：段基址：段限长</p>
<h2 id="分页（基本分页管理方式）"><a href="#分页（基本分页管理方式）" class="headerlink" title="分页（基本分页管理方式）"></a>分页（基本分页管理方式）</h2><p>分页：将主存空间划分大小相等且较小的块，作为主存的基本单位，进程也以这个块为单位划分，在运行过程以这个块为单位请求内存。</p>
<p>逻辑地址：页号：页内偏移</p>
<h3 id="分页硬件"><a href="#分页硬件" class="headerlink" title="分页硬件"></a>分页硬件</h3><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-06-17-27-17.png" alt></p>
<h2 id="分段和分页的区别"><a href="#分段和分页的区别" class="headerlink" title="分段和分页的区别"></a>分段和分页的区别</h2><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-06-17-32-55.png" alt></p>
<h1 id="Page-Table"><a href="#Page-Table" class="headerlink" title="Page Table"></a>Page Table</h1><h2 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h2><p>若逻辑地址长度为m bits，页面大小为$2^n$ Bytes:</p>
<ul>
<li>页内位移占n bits</li>
<li>页号占m-n bits  </li>
</ul>
<p>获取Linux系统页大小的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf PAGESIZE</span><br></pre></td></tr></table></figure></p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>操作系统会为每个进程都维护一个页表，该页表的作用是将逻辑地址转为物理地址，它会被CPU调度程序用来定义硬件页表当一个进程被分配到CPU的时候。当然，页表会增加上下文切换的开销。</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>最高级页表项不能超过一页</p>
<h3 id="HARDWARE-PAGE-TABLE"><a href="#HARDWARE-PAGE-TABLE" class="headerlink" title="HARDWARE PAGE TABLE"></a>HARDWARE PAGE TABLE</h3><p>页表被保存在内存中，而且一个page table base register 指向页表。<br>切换页表只需要切换这个寄存器，减少了上下文切换的开销。  </p>
<h2 id="TLB-hardware"><a href="#TLB-hardware" class="headerlink" title="TLB(hardware)"></a>TLB(hardware)</h2><ul>
<li>TLB只包含一部分页表项</li>
<li>当CPU生成一个逻辑地址时，它的页号被送到TLB</li>
<li>如果页号被找到，则它的页框号可以马上找到，此时只需要访问一次内存。</li>
<li>如果TLB未命中，则要访问页表，此时需要访问两次内存<h2 id="基于页的保护和共享"><a href="#基于页的保护和共享" class="headerlink" title="基于页的保护和共享"></a>基于页的保护和共享</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3>为了防止地址转换出现异常，可在页表条目设置一个“vaild-invaild”比特位，用于表示该项的有效性。<br>这个方法可以被扩展以提供更好的保护级别，如“只读”“读写”“可执行”等。  <h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3>不同进程共享一样的页框，这个页框只能为pure code（read only）<h2 id="多级页表-1"><a href="#多级页表-1" class="headerlink" title="多级页表"></a>多级页表</h2>为减少页表的大小，采用多级页表的方式<h2 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h2>作业的地址空间被分成若干逻辑段，然后将每段分成固定大小的页。<br>系统为每个进程建立一张段表，每个分段有一张页表。</li>
</ul>
<p>逻辑结构地址：</p>
<p>段号+页号+页内偏移地址</p>
<h1 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><ul>
<li>时间局部性：如果某个信息这次被访问，那它可能在不久的将来被多次访问</li>
<li>空间局部性：如果某个位置的信息被访问，那和它相邻的信息也可能被访问到</li>
<li>分支局部性：顺序指令和非顺序执行的的比例大致为5：1</li>
</ul>
<h2 id="修改缓存数据"><a href="#修改缓存数据" class="headerlink" title="修改缓存数据"></a>修改缓存数据</h2><ul>
<li>write through：修改缓存数据的同时修改内存数据</li>
<li>write back：修改缓存数据的时候不修改内存数据，直到该数据要被清除出缓存的时候再修改内存中的数据</li>
</ul>
<h2 id="部分装入和部分对换"><a href="#部分装入和部分对换" class="headerlink" title="部分装入和部分对换"></a>部分装入和部分对换</h2><ul>
<li>部分装入：进程运行时仅加载部分内存，而不必全部装入，其余部分暂时装入swap space</li>
<li>部分的兑换：可以将进程部分对换出内存，用以腾出内存空间，对换的部分暂时放在swap space<br>swap space时磁盘的一部分<br>磁盘带来容量，内存带来速度。</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存的一个主要的好处是程序能够比物理内存</p>
<p>虚拟内存技术的实现基于非连续的内存管理</p>
<h3 id="虚拟内存的空间大小"><a href="#虚拟内存的空间大小" class="headerlink" title="虚拟内存的空间大小"></a>虚拟内存的空间大小</h3><ul>
<li>虚存的实际容量 &lt;= 内存容量+外村容量，这是硬件的硬性条件决定的</li>
<li>虚存的最大容量 &lt;= 计算机的地址位数能容纳的最大容量</li>
</ul>
<h2 id="请求调页管理方式"><a href="#请求调页管理方式" class="headerlink" title="请求调页管理方式"></a>请求调页管理方式</h2><p>只需要加载一部分页面到内存中，就可以启动页面。</p>
<p>与基本分页管理方式的区别：所有的页面只有再被请求的时候才加载进入内存，如果一个页面从来不会被访问就不会加载进内存。<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-00-22-09.png" alt></p>
<p>内存分配策略：</p>
<ul>
<li>固定分配局部置换</li>
<li>可变分配全局置换</li>
<li>可变分配局部置换</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>总是淘汰最先进入内存的页面</p>
<ul>
<li>Belady异常：页帧数增加不一定能减少page fault。</li>
</ul>
<h3 id="OPTIMAL"><a href="#OPTIMAL" class="headerlink" title="OPTIMAL"></a>OPTIMAL</h3><p>总是淘汰最长时间不会使用的页面  </p>
<ul>
<li>无法实现，无法预测未来</li>
</ul>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>总是淘汰最近最少使用的页面</p>
<ul>
<li>需要排序，实现起来耗费高</li>
</ul>
<p>OPT &gt; LRU &gt;FIFO</p>
<h3 id="CLOCK（NRU）"><a href="#CLOCK（NRU）" class="headerlink" title="CLOCK（NRU）"></a>CLOCK（NRU）</h3><p>每页设置一个访问位，当某页被创建或被访问时，设置为1。当选择一页淘汰时，若该页为1则修改为0，给予第二次留在内存的机会，若该页为0则淘汰出内存。若循环一次后未找到为0的页则继续循环。即最近未被访问页面被淘汰。</p>
<ul>
<li>优化后的CLOCK：增加修改位，每次淘汰需要考虑修改位（因为如果某页被修改，需要写回磁盘，增大了I/O负担），优先级小于访问位</li>
</ul>
<h2 id="系统抖动"><a href="#系统抖动" class="headerlink" title="系统抖动"></a>系统抖动</h2><p>请求调页此时，进程的所有页面都在被使用，所以当调页完成后，又会马上发生缺页中断，此时又需要调页。<br>如果一个进程的执行时间小于进程的调页时间，这个现象就叫抖动。</p>
<h3 id="抖动的原因"><a href="#抖动的原因" class="headerlink" title="抖动的原因"></a>抖动的原因</h3><ul>
<li>并发进程过多-&gt;进程页框不够</li>
<li>进程页框分配不合理<h2 id="PFF，缺页故障率"><a href="#PFF，缺页故障率" class="headerlink" title="PFF，缺页故障率"></a>PFF，缺页故障率</h2>基于这个数据可以实施一个防止抖动的策略：动态调节分配给进程的数量。<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-10-14-23.png" alt><br>从实际的角度出发：最好的策略为加内存条</li>
</ul>
<h1 id="Mass-Storage"><a href="#Mass-Storage" class="headerlink" title="Mass Storage"></a>Mass Storage</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-10-23-13.png" alt><br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-10-27-29.png" alt></p>
<h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><ul>
<li>高级格式化：构建格式化，在磁盘初始化文件系统数据结构</li>
<li>低级格式化：为每个扇区使用特殊的数据结构进行填充，包括一个头部，数据区域，尾部。头部可能包含区域编号，尾部可能包含校验码<h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3>查找物理块的顺序；柱面号，磁头号，扇区号<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-13-10-48-22.png" alt></li>
</ul>
<p>$T_r=\frac{1}{2r}$，注意顺序访问时只有第一个磁道有旋转延迟时间</p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><h3 id="DISK-I-O-REQUEST"><a href="#DISK-I-O-REQUEST" class="headerlink" title="DISK I/O REQUEST"></a>DISK I/O REQUEST</h3><p>无论什么时候一个进程需要去读写进程，会发出一个系统调用给操作系统，这个系统调用几个信息：</p>
<ul>
<li>这个操作是输入还是输出</li>
<li>磁盘传输数据的地址【柱面，磁头，扇区】虚拟成LBA</li>
<li>内存传输数据的地址</li>
<li>传输数据的扇区数量<h3 id="DISK-SCHEDULING"><a href="#DISK-SCHEDULING" class="headerlink" title="DISK SCHEDULING"></a>DISK SCHEDULING</h3>对于并发进程系统，同一时刻会发出大量的磁盘I/O请求，操作系统会维护一个磁盘队列，当一个请求访问结束，操作系统就会在磁盘队列中选一个请求开始服务  </li>
<li>FCFS：先来先服务 对于SSD来说已经足够</li>
<li>SSTF：最短寻道时间优先-&gt;磁臂粘连现象-&gt;饥饿</li>
<li>SCAN：来回服务请求</li>
<li>LOOK：不用到终点即可返回</li>
<li>C-SCAN（循环扫描）：负载均衡，固定方向（直接快速回到起始端，SCAN（电梯调度算法）会偏向于处理那些接近最里或最外的磁道），最实用</li>
<li>C-LOOK：based on C-SCAN 不用到终点再折返，只要到了最远的一个端点就可以返回了</li>
</ul>
<h2 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h2><h3 id="固态硬盘的特性"><a href="#固态硬盘的特性" class="headerlink" title="固态硬盘的特性"></a>固态硬盘的特性</h3><p>固态硬盘是一种基于闪存技术的存储器，和U盘并无本质差别，只是容量更大，存取性能更好。</p>
<h3 id="磨损均衡"><a href="#磨损均衡" class="headerlink" title="磨损均衡"></a>磨损均衡</h3><p>闪存的擦写寿命有限。如果读写数据集中在SSD的一部分闪存，那这部分闪存的寿命会损耗得特别快。</p>
<p>为了弥补SSD得寿命缺陷，引入磨损均衡：</p>
<ul>
<li>动态磨损均衡。写入数据时，自动选择较新得闪存快</li>
<li>静态磨损均衡：更为先进，SSD检测自动进行数据分配，让老的得闪存块无须承担数据的存储任务，同时让较新的闪存块腾出空间</li>
</ul>
<h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>对于大多数用户来说，文件系统是一个最显而易见的操作系统的一部分。<br>它提供了存储和访问操作系统和用户的数据和程序的机制。<br>文件系统包含两个部分：</p>
<ul>
<li>文件的集合，每个文件包含数据</li>
<li>目录（管理和提供关于文件系统所有文件的信息）<h2 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h2><h3 id="文件定义"><a href="#文件定义" class="headerlink" title="文件定义"></a>文件定义</h3>在用户看来：文件是具有结构的信息集合<br>在操作系统看来：文件的本质是存储在外存当中的二进制集合  <h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3>文件是“按名存取”的<br>属性：  </li>
<li>文件名:按名存取！</li>
<li>文件类型-&gt;后缀</li>
<li>位置</li>
<li>大小</li>
<li>时间、日期和用户标识</li>
<li>保护<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3>文件类型可用于指示文件的内部结构，操作系统通过了解文件类型决定如何进行解释。<br>一般地，操作系统至少要解释两种文件类型：</li>
<li>文本文件</li>
<li>二进制可执行文件<ul>
<li>Windows： .exe</li>
<li>Linux： ./</li>
</ul>
</li>
</ul>
<p>Unix认为每个文件由字节序列组成，解释这些序列的工作交给具体的应用程序来做。所以对于未知的文件类型，操作系统选择对应的应用程序去出来。  </p>
<p>Unix把设备视作特殊文件</p>
<h3 id="文件内部结构"><a href="#文件内部结构" class="headerlink" title="文件内部结构"></a>文件内部结构</h3><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-18-08-50-05.png" alt></p>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><ul>
<li>顺序访问：读取/写入当前文件后，将文件指针移向下一个邻接区域</li>
<li>直接访问：若文件的逻辑记录的长度固定，那么在访问文件可按任意顺序进行快速读写。（从文件开始位置的L*N个L字节）<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2>目录可以被看作一个翻译文件名成对应entry的符号表。<br>一种保存文件控制信息的数据结构<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-18-09-13-51.png" alt><br>作用：</li>
<li>列出所有文件</li>
<li>增加文件</li>
<li>删除文件</li>
<li>更名</li>
</ul>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>单层目录结构：所有的文件都保存在同一个目录下<ul>
<li>容易实现和理解</li>
<li>命名是个很大的问题</li>
</ul>
</li>
<li>两层目录结构：每个用户有一个自己目录（UFD）</li>
<li>树形结构目录：一个树形结构有一个根目录，在这个系统中的每个文件都有一个独一无二的路径名</li>
</ul>
<h2 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h2><ul>
<li>创建文件<ul>
<li>为新文件分配必要的外存空间</li>
<li>在目录中为其创建一个目录项</li>
</ul>
</li>
<li>读文件：执行系统调用然后在目录中搜索文件，维护一个读指针</li>
<li>写文件：与读文件类似</li>
<li>重新定位文件：将文件位置指针重新定位</li>
<li>删除文件：<ul>
<li>搜索文件</li>
<li>释放空间</li>
<li>删除目录项</li>
</ul>
</li>
<li>截断文件：不改变文件属性，但是删除文件内容</li>
</ul>
<h3 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h3><p>打开：调用open根据文件名搜索目录，将文件的属性复制到内存打开文件表的一个表目中，并将表目的索引返回给用户（文件句柄，文件描述符）</p>
<p>关闭类似</p>
<h2 id="共享与保护"><a href="#共享与保护" class="headerlink" title="共享与保护"></a>共享与保护</h2><ul>
<li>User：即所有者（owner）</li>
<li>Group：用户集合，拥有相同的权限</li>
</ul>
<p>文件保护通过口令保护，加密保护和访问控制等方式实现。  </p>
<p>口令和加密保护是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式</p>
<h3 id="文件访问控制"><a href="#文件访问控制" class="headerlink" title="文件访问控制"></a>文件访问控制</h3><p>每个文件/目录关联一个访问控制表ACL</p>
<ul>
<li>每个文件/目录有三种用户类型：Owner/Group/Other</li>
<li>三种用户的访问控制权限均有rwx</li>
<li>每个ACL有九个bit</li>
</ul>
<p>对于文件的访问控制，由<strong>用户访问权限</strong>和<strong>文件属性</strong>共同限制</p>
<h1 id="File-System-Implementation"><a href="#File-System-Implementation" class="headerlink" title="File-System Implementation"></a>File-System Implementation</h1><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-10-53-24.png" alt></p>
<h2 id="common-file-system"><a href="#common-file-system" class="headerlink" title="common file system"></a>common file system</h2><p>当今有许多文件系统被使用，大多数操作系统都支持多种文件系统</p>
<h2 id="文件目录-1"><a href="#文件目录-1" class="headerlink" title="文件目录"></a>文件目录</h2><p>文件系统通过文件控制块来维护文件结构，FCB包含有关文件的信息，包括所有者，权限，文件内容的位置等   </p>
<p>FCB主要包含以下信息：</p>
<ul>
<li>文件基本信息</li>
<li>存取控制信息</li>
<li>使用信息</li>
</ul>
<p>文件目录用于组织文件，每个目录项对于一个FCB<br>文件目录实现的关键：</p>
<ul>
<li>FCB与文件内容的关联方法</li>
<li>在目录种“按名”搜索的效率<ul>
<li>线性表</li>
<li>哈希表</li>
</ul>
</li>
</ul>
<p>UFS（unix file system）：UFS的FCB被称作索引节点inode，每个inode都有唯一的一个编号。UFS的目录条目只包含了文件名和inode编号。创建文件数量上限=索引节点数量上限。<br>UFS根据文件名在目录中找到相应的inode编号，再根据inode编号找到文件的相关信息。<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-15-54-11.png" alt></p>
<p>文件目录结构：</p>
<ul>
<li>一级目录</li>
<li>二级目录</li>
<li>树形结构：可以从当前目录下开始检索</li>
</ul>
<h2 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h2><h3 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h3><p>文件信息按顺序排序，读取/写入当前文件信息后，将文件指针移向下一区域</p>
<p><strong>磁带模型</strong></p>
<h3 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h3><p>若文件的逻辑记录的长度固定，那么允许在访问文件信息时可按任意顺序快速读取和写入</p>
<h2 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h2><h3 id="连续分配："><a href="#连续分配：" class="headerlink" title="连续分配："></a>连续分配：</h3><p>每个文件在磁盘上占用连续的物理块</p>
<ul>
<li>简单，地址转换很快（+）随机存取</li>
<li>碎片（-）</li>
<li>文件的增加和修改不方便（-），可能需要移动整个文件才能得到更大的空间</li>
</ul>
<p>磁带是一种顺序存储设备，用它存储文件时只能采用顺序存储结构。</p>
<p>采用连续分配能够提高访问速度。</p>
<h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p>文件分散在磁盘的不同位置，通过指针将他们链接起来</p>
<ul>
<li>没有碎片（+）</li>
<li>空间浪费了一部分（-）用了一部分空间存储指针</li>
<li>来自断链的风险（-）</li>
<li>访问文件必须从头顺序访问（-），即不可以随机存取<h3 id="簇"><a href="#簇" class="headerlink" title="簇"></a>簇</h3>指一组物理块的集合。如果以簇为分配的单位，可以节省指针占用的空间比例<h3 id="文件分配表FAT（显示链接）"><a href="#文件分配表FAT（显示链接）" class="headerlink" title="文件分配表FAT（显示链接）"></a>文件分配表FAT（显示链接）</h3>用一张表来记录文件占用物理块的号的顺序</li>
<li>仍然不能完成随机访问<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-15-49-02.png" alt>  <h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3>将文件占用的所有物理块号按逻辑顺序保存在一张索引表中，存有索引表的物理块称为索引块。</li>
<li>实现了随机访问（+）</li>
<li>索引块占用空间（-）</li>
<li>索引块占用多少空间不确定(-)<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-15-59-14.png" alt></li>
</ul>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><h3 id="Bit-Map"><a href="#Bit-Map" class="headerlink" title="Bit Map"></a>Bit Map</h3><p>每一个扇区的空闲情况有一个比特来表示</p>
<p>盘块号 = 起始块号+floor（盘块号/（盘块大小*8））</p>
<h3 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h3><p>将所有的空闲空间链接起来，在一个特殊的地方存放头指针<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-20-16-04.png" alt></p>
<h2 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h2><h3 id="layered-file-system"><a href="#layered-file-system" class="headerlink" title="layered file system"></a>layered file system</h3><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-20-19-48.png" alt></p>
<h3 id="virtual-file-system"><a href="#virtual-file-system" class="headerlink" title="virtual file system"></a>virtual file system</h3><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-20-24-59.png" alt></p>
<p>四种对象：</p>
<ul>
<li>超级块对象</li>
<li>索引节点对象</li>
<li>目录项对象</li>
<li>文件对象</li>
</ul>
<h1 id="I-O-System"><a href="#I-O-System" class="headerlink" title="I/O System"></a>I/O System</h1><h2 id="I-O硬件"><a href="#I-O硬件" class="headerlink" title="I/O硬件"></a>I/O硬件</h2><ul>
<li>Mother Board</li>
<li>总线：一组线路和通过线路传输的协议<ul>
<li>并行：占的面积较大，并且容易发生干扰</li>
<li>串行：例如PCIe，SATA，USB  </li>
</ul>
</li>
<li>ports：<ul>
<li>PCIe</li>
<li>SATA</li>
<li>USB（Universal Serial Bus） </li>
<li>VGA</li>
<li>HDMI</li>
<li>DVI<h3 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h3></li>
</ul>
</li>
<li>块设备：存取单位为一个block，传输速率高，可寻址，可随机读写</li>
<li>字符设备：存取单位为一个字符，传输速率低，不可寻址，时常采用中断I/O</li>
<li>共享设备：一段时间内允许多个进程同时访问的设备</li>
<li><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-25-20-53-22.png" alt><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3></li>
<li><p>I/O接口：</p>
<p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/de970afca866dea878ad543e12f58c4.jpg" alt="de970afca866dea878ad543e12f58c4"></p>
<p>设备控制器的组成部分：</p>
<ul>
<li>设备控制器与CPU的接口</li>
<li>设备控制器与设备的接口</li>
<li>I/O逻辑。设备控制器通过对CPU发送来的指令进行译码来控制设备。</li>
</ul>
</li>
</ul>
<h3 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h3><p>控制器有一个或多个用于数据和控制信号的寄存器。CPU通过直接读写这些寄存器来控制通信。</p>
<ul>
<li>控制寄存器</li>
<li>状态寄存器</li>
<li>数据寄存器<h3 id="I-O地址"><a href="#I-O地址" class="headerlink" title="I/O地址"></a>I/O地址</h3>I/O地址：控制寄存器地址<br>编址方式：</li>
<li>I/O独立编址：为每个端口分配一个端口号，所有I/O端口形成一个端口空间，普通用户不能对其进行访问。使用独立的I/O指令，如IN，OUT</li>
<li>内存映射编址（统一编址）：划出一块内存地址，将I/O端口的地址映射起来，这样就可以用访问内存指令对控制寄存器进行读写。每个端口被分配唯一的内存地址<br>内存映射编址：<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-10-21-58.png" alt></li>
</ul>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><ul>
<li><p>轮询：</p>
<p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-10-37-39.png" alt>  </p>
<ul>
<li>缺点：串行工作，极大浪费CPU资源</li>
</ul>
</li>
<li><p>中断：<img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-10-43-19.png" alt></p>
</li>
<li><p>DMA直接内存访问：<img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-10-49-50.png" alt></p>
<h2 id="内核I-O结构"><a href="#内核I-O结构" class="headerlink" title="内核I/O结构"></a>内核I/O结构</h2><p>内核I/O结构包括硬件和软件两个部分，I/O软件的设计目标主要体现在：</p>
</li>
<li>高效性</li>
<li>通用性：屏蔽硬件细节，让用户使用统一的接口方便地使用不同硬件</li>
</ul>
<p>内核I/O结构图：<br><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-11-01-09.png" alt><br>设备驱动层来提供统一的接口，从而对I/O子系统隐藏了I/O设备的控制器</p>
<p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2ba0fe81d0d2031fac8d7306da71a39.jpg" alt="2ba0fe81d0d2031fac8d7306da71a39"></p>
<ul>
<li>用户从I/O软件</li>
<li>设备独立性软件<ul>
<li>在应用程序中使用逻辑设备名请求设备，在系统实际执行时需要把逻辑设备名映射为物理设备名</li>
<li>执行所有设备的公有操作</li>
<li>向用户层提供统一接口</li>
</ul>
</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
</ul>
<h3 id="I-O请求周期"><a href="#I-O请求周期" class="headerlink" title="I/O请求周期"></a>I/O请求周期</h3><p><img src="/2024/01/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2024-03-27-11-31-11.png" alt></p>
<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="虚拟存储器的特点？"><a href="#虚拟存储器的特点？" class="headerlink" title="虚拟存储器的特点？"></a>虚拟存储器的特点？</h2><ol>
<li>虚拟扩充，从逻辑上而不是物理上扩充了内存容量</li>
<li>部分装入，即每个作业并不是一次性全部装入内存</li>
<li>离散分配，即不必占用连续的地址空间</li>
<li>缺点：<ol>
<li>缺页中断增加了系统开销</li>
<li>可能产生抖动</li>
<li>增加了硬件成本</li>
</ol>
</li>
</ol>
<h2 id="分时操作系统和实时操作系统的区别？"><a href="#分时操作系统和实时操作系统的区别？" class="headerlink" title="分时操作系统和实时操作系统的区别？"></a>分时操作系统和实时操作系统的区别？</h2><ul>
<li>分时操作系统：一种利用分时技术的联机的多用户交互式的系统，每个用户都可以通过终端向系统发出各种操控命令。分时技术就是把处理机的运行时间分成很小的时间片，按时间片轮流把处理机分配给联机作业使用。</li>
<li>实时操作系统：一种能在特定或确定的时间能完成系统功能以及对内部或外部事件按同步或异步的方式做出响应的系统。</li>
</ul>
<h2 id="简述多道程序设计技术？"><a href="#简述多道程序设计技术？" class="headerlink" title="简述多道程序设计技术？"></a>简述多道程序设计技术？</h2><p>多道程序设计技术是指把多个程序同时存放在内存中并启动交替计算，在宏观上是并行，微观上是串行，轮流占有CPU。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ol>
<li>进程是操作系统进行资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>线程依赖于进程而存在，一个进程至少拥有一个线程</li>
<li>进程拥有独立的地址空间，而线程共享所属进程的资源，除了自身运行的必须资源外，线程没有其他资源，所以线程的切换创建等都比进程开销更小。</li>
<li>进程通信必须用进程间通信的方式，而线程通信比较方便。</li>
<li>线程崩溃可能导致所属进程都会崩溃，而进程崩溃不影响其他进程。</li>
</ol>
<h2 id="什么是进程，和程序的区别？"><a href="#什么是进程，和程序的区别？" class="headerlink" title="什么是进程，和程序的区别？"></a>什么是进程，和程序的区别？</h2><ul>
<li>定义：进程是拥有独立功能的程序在一些数据集合上的一次运行过程。是系统进行资源分配和调度的单位。</li>
<li>区别：<ul>
<li>进程是一次运行过程，是暂时的，有创建有撤销。程序是永久的。</li>
<li>进程是动态的，程序是静态的。</li>
</ul>
</li>
</ul>
<h2 id="进程进入临界区的调度原则"><a href="#进程进入临界区的调度原则" class="headerlink" title="进程进入临界区的调度原则?"></a>进程进入临界区的调度原则?</h2><ul>
<li>空闲让进：如果临界区空闲则允许一个进程进入。</li>
<li>忙则等待：任何时候，处于临界区内的进程不可多于一个。所以临界区不空闲的时候，外面的进程必须等待</li>
<li>有限等待：等待的时间是有限的。</li>
<li>让权等待：如果进程不能进入临界区，应该让出“CPU”，避免忙等</li>
</ul>
<h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB?"></a>PCB?</h2><p>PCB是进程实体的一部分，是操作系统中一个非常重要的记录型数据结构，包含了操作系统用于描述进程情况和控制进程允许所需的全部信息。</p>
<h2 id="内存管理的功能？"><a href="#内存管理的功能？" class="headerlink" title="内存管理的功能？"></a>内存管理的功能？</h2><ul>
<li>内存空间的回收与分配</li>
<li>地址转换</li>
<li>内存共享</li>
<li>存储保护</li>
</ul>
<h2 id="页式存储管理和段式存储管理的区别？"><a href="#页式存储管理和段式存储管理的区别？" class="headerlink" title="页式存储管理和段式存储管理的区别？"></a>页式存储管理和段式存储管理的区别？</h2><ol>
<li>页式存储管理的逻辑地址是连续的，而段式可以不连续（段号与段号之间无联系，而页号按顺序增加）</li>
<li>页式的逻辑地址是一维的，而段式是二维的</li>
<li>每一页的大小是固定的，而每一段的大小不一定相同</li>
</ol>
<p>页式：</p>
<ul>
<li>优点：没有外部碎片，内部碎片不大</li>
<li>缺点：地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。页与页之间没有了逻辑联系，无法进行共享和保护。</li>
</ul>
<p>段式：</p>
<ul>
<li>优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。</li>
<li>缺点：外部碎片</li>
</ul>
<h2 id="缓冲技术的目的？"><a href="#缓冲技术的目的？" class="headerlink" title="缓冲技术的目的？"></a>缓冲技术的目的？</h2><ol>
<li>缓和CPU和I/O之间速度不匹配的问题</li>
<li>提高CPU和I/O之间的并行性</li>
<li>解决数据颗粒度不匹配的问题</li>
<li>减少CPU中断的频率</li>
</ol>
<h2 id="什么是通道？"><a href="#什么是通道？" class="headerlink" title="什么是通道？"></a>什么是通道？</h2><p>通道本质是一个简单的处理器，具有控制输入输出，执行I/O指令的功能，可以通过执行I/O通道程序控制I/O操作。</p>
<h2 id="磁盘访问时间由哪三部分组成？"><a href="#磁盘访问时间由哪三部分组成？" class="headerlink" title="磁盘访问时间由哪三部分组成？"></a>磁盘访问时间由哪三部分组成？</h2><ol>
<li>寻道时间：磁头移动到指定磁道的时间</li>
<li>旋转延迟时间：指定扇区旋转到磁头下的时间</li>
<li>数据传输时间：将从内存传输到磁盘或从磁盘传输到内存的时间</li>
</ol>
<h2 id="简述中断处理过程"><a href="#简述中断处理过程" class="headerlink" title="简述中断处理过程"></a>简述中断处理过程</h2><ol>
<li>保护被中断进程的现场，保存被中断进程的PCB</li>
<li>分析中断原因，执行相应的中断处理程序</li>
<li>恢复被中断进程的现场，继续执行被中断进程</li>
</ol>
<h2 id="用户级线程和系统级线程的优缺点"><a href="#用户级线程和系统级线程的优缺点" class="headerlink" title="用户级线程和系统级线程的优缺点"></a>用户级线程和系统级线程的优缺点</h2><p>用户级线程：</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>线程切换不用切换到内核模式，节省了模式切换的开销</p>
</li>
<li><p>调度算法可以是进程专用的，不同的进程可以按照需要给线程使用不同的调度算法</p>
</li>
<li><p>用户级线程的实现与操作系统的平台无关，由用户程序自己管理线程代码，所以可以运行在任意操作系统上。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>一个线程被阻塞，该线程所属进程的所有线程都会被阻塞</li>
<li>内核每次分给一个进程的就一个CPU，不能发挥多线程优势</li>
</ul>
</li>
</ul>
<p>内核级线程：</p>
<ul>
<li>优点：<ul>
<li>能同时调度同一进程中的多个线程并行执行，发挥多处理机的优势</li>
<li>如果一个线程被阻塞，内核可以调度其他线程占用处理机</li>
<li>内核本身也可以采用多线程技术，提高系统的执行速度和效率</li>
</ul>
</li>
<li>缺点：<ul>
<li>同一进程的线程切换也需要切换到内核模式，系统开销较大</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/schedule.html"><strong>mit操作系统课程6.S081</strong></a><br><a target="_blank" rel="noopener" href="https://blog.miigon.net/posts/"><strong>6.S081 labs answer</strong></a><br><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/"><strong>6.S081课程记录（中文）</strong></a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/408/" rel="tag"># 408</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/" rel="prev" title="二叉树遍历问题">
      <i class="fa fa-chevron-left"></i> 二叉树遍历问题
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/01/23/paper-report/" rel="next" title="paper report">
      paper report <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-system-Structure"><span class="nav-number">1.</span> <span class="nav-text">Operating-system Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统结构分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">两个接口：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dual-mode%EF%BC%88%E7%94%A8%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E6%A8%A1%E5%BC%8F%E4%BD%8D%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E6%A8%A1%E5%BC%8F%E4%BD%8D%EF%BC%89%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">dual mode（用一个硬件模式位来表示当前模式位）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-number">1.4.</span> <span class="nav-text">系统调用实现机制：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-Concept"><span class="nav-number">1.5.</span> <span class="nav-text">Process Concept</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">1.6.</span> <span class="nav-text">进程的定义：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-in-Memory"><span class="nav-number">1.7.</span> <span class="nav-text">Process in Memory:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%9A"><span class="nav-number">1.8.</span> <span class="nav-text">并发和并行：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-State%EF%BC%9A"><span class="nav-number">1.9.</span> <span class="nav-text">Process State：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%9A"><span class="nav-number">1.10.</span> <span class="nav-text">进程切换：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Process-Scheduling"><span class="nav-number">2.</span> <span class="nav-text">Process Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF"><span class="nav-number">2.1.</span> <span class="nav-text">中断技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%BA%90%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">中断源：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">中断向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">2.4.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%EF%BC%9A"><span class="nav-number">2.5.</span> <span class="nav-text">模式切换：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%9A-1"><span class="nav-number">2.6.</span> <span class="nav-text">进程切换：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88%E7%8A%B6%E6%80%81%EF%BC%89PCB"><span class="nav-number">2.7.</span> <span class="nav-text">进程控制块（状态）PCB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97%EF%BC%9A"><span class="nav-number">2.8.</span> <span class="nav-text">进程队列：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">2.9.</span> <span class="nav-text">进程的通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Thread"><span class="nav-number">3.</span> <span class="nav-text">Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">线程的定义：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">多线程模型：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU-Scheduleing"><span class="nav-number">4.</span> <span class="nav-text">CPU Scheduleing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.1.</span> <span class="nav-text">CPU调度程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="nav-number">4.2.</span> <span class="nav-text">CPU调度准则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">调度算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Synchronization"><span class="nav-number">5.</span> <span class="nav-text">Synchronization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">5.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%BC%95%E5%8F%91%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">5.2.</span> <span class="nav-text">异步引发的异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">5.3.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">5.4.</span> <span class="nav-text">管程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mutex-Locks"><span class="nav-number">6.</span> <span class="nav-text">Mutex Locks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.</span> <span class="nav-text">临界区问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AE%A1%E7%90%86%E8%A7%84%E5%88%99"><span class="nav-number">6.2.</span> <span class="nav-text">临界区管理规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%A7%A3%E5%86%B3%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-number">6.3.</span> <span class="nav-text">软件解决临界区管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">6.4.</span> <span class="nav-text">互斥锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Semaphores"><span class="nav-number">7.</span> <span class="nav-text">Semaphores</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">7.1.</span> <span class="nav-text">信号量的实现：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">7.1.1.</span> <span class="nav-text">整数型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">7.1.2.</span> <span class="nav-text">记录型信号量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">7.2.</span> <span class="nav-text">信号量的使用：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">7.3.</span> <span class="nav-text">信号量实现同步问题：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Deadlocks"><span class="nav-number">8.</span> <span class="nav-text">Deadlocks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">8.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E7%94%A8%E9%A4%90%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.</span> <span class="nav-text">哲学家用餐死锁问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A5%A5%E9%A5%BF-vs-%E6%AD%BB%E9%94%81"><span class="nav-number">8.3.</span> <span class="nav-text">饥饿 vs 死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">8.4.</span> <span class="nav-text">产生死锁的必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">8.5.</span> <span class="nav-text">死锁的解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E6%8E%A5%E8%A7%A6"><span class="nav-number">8.6.</span> <span class="nav-text">死锁的检测和接触</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Memory-Mangement"><span class="nav-number">9.</span> <span class="nav-text">Memory Mangement</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E5%85%A5"><span class="nav-number">9.1.</span> <span class="nav-text">程序的链接和装入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%AE%E6%A0%87"><span class="nav-number">9.2.</span> <span class="nav-text">内存管理目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Main-Memory"><span class="nav-number">9.3.</span> <span class="nav-text">Main Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="nav-number">9.4.</span> <span class="nav-text">保护操作系统和用户进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">9.5.</span> <span class="nav-text">逻辑地址和物理地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83MMU"><span class="nav-number">9.6.</span> <span class="nav-text">内存管理单元MMU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Contiguous-Memory-Allocation"><span class="nav-number">9.7.</span> <span class="nav-text">Contiguous Memory Allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-number">9.7.1.</span> <span class="nav-text">单一连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fixed-Sized-Partition"><span class="nav-number">9.7.2.</span> <span class="nav-text">Fixed-Sized Partition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Variable-Partition"><span class="nav-number">9.7.3.</span> <span class="nav-text">Variable Partition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A2%8E%E7%89%87"><span class="nav-number">9.7.4.</span> <span class="nav-text">碎片</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Segmenting-and-Paging"><span class="nav-number">10.</span> <span class="nav-text">Segmenting and Paging</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%9C%BA"><span class="nav-number">10.1.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="nav-number">10.2.</span> <span class="nav-text">分段（基本分段管理方式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E7%A1%AC%E4%BB%B6"><span class="nav-number">10.2.1.</span> <span class="nav-text">分段硬件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="nav-number">10.3.</span> <span class="nav-text">分页（基本分页管理方式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E7%A1%AC%E4%BB%B6"><span class="nav-number">10.3.1.</span> <span class="nav-text">分页硬件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.4.</span> <span class="nav-text">分段和分页的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Page-Table"><span class="nav-number">11.</span> <span class="nav-text">Page Table</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F"><span class="nav-number">11.1.</span> <span class="nav-text">页面大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">11.2.</span> <span class="nav-text">页表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">11.2.1.</span> <span class="nav-text">多级页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HARDWARE-PAGE-TABLE"><span class="nav-number">11.2.2.</span> <span class="nav-text">HARDWARE PAGE TABLE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TLB-hardware"><span class="nav-number">11.3.</span> <span class="nav-text">TLB(hardware)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%B5%E7%9A%84%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="nav-number">11.4.</span> <span class="nav-text">基于页的保护和共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4"><span class="nav-number">11.4.1.</span> <span class="nav-text">保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB"><span class="nav-number">11.4.2.</span> <span class="nav-text">共享</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8-1"><span class="nav-number">11.5.</span> <span class="nav-text">多级页表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="nav-number">11.6.</span> <span class="nav-text">段页式管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Virtual-Memory"><span class="nav-number">12.</span> <span class="nav-text">Virtual Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">12.1.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="nav-number">12.2.</span> <span class="nav-text">修改缓存数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E8%A3%85%E5%85%A5%E5%92%8C%E9%83%A8%E5%88%86%E5%AF%B9%E6%8D%A2"><span class="nav-number">12.3.</span> <span class="nav-text">部分装入和部分对换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">12.4.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="nav-number">12.4.1.</span> <span class="nav-text">虚拟内存的空间大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">12.5.</span> <span class="nav-text">请求调页管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">12.6.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FIFO"><span class="nav-number">12.6.1.</span> <span class="nav-text">FIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OPTIMAL"><span class="nav-number">12.6.2.</span> <span class="nav-text">OPTIMAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU"><span class="nav-number">12.6.3.</span> <span class="nav-text">LRU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLOCK%EF%BC%88NRU%EF%BC%89"><span class="nav-number">12.6.4.</span> <span class="nav-text">CLOCK（NRU）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%8A%96%E5%8A%A8"><span class="nav-number">12.7.</span> <span class="nav-text">系统抖动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">12.7.1.</span> <span class="nav-text">抖动的原因</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PFF%EF%BC%8C%E7%BC%BA%E9%A1%B5%E6%95%85%E9%9A%9C%E7%8E%87"><span class="nav-number">12.8.</span> <span class="nav-text">PFF，缺页故障率</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mass-Storage"><span class="nav-number">13.</span> <span class="nav-text">Mass Storage</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="nav-number">13.1.</span> <span class="nav-text">磁盘结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">13.1.1.</span> <span class="nav-text">磁盘格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">13.1.2.</span> <span class="nav-text">磁盘性能指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-number">13.2.</span> <span class="nav-text">磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DISK-I-O-REQUEST"><span class="nav-number">13.2.1.</span> <span class="nav-text">DISK I&#x2F;O REQUEST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISK-SCHEDULING"><span class="nav-number">13.2.2.</span> <span class="nav-text">DISK SCHEDULING</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSD"><span class="nav-number">13.3.</span> <span class="nav-text">SSD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">13.3.1.</span> <span class="nav-text">固态硬盘的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1"><span class="nav-number">13.3.2.</span> <span class="nav-text">磨损均衡</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#File-System"><span class="nav-number">14.</span> <span class="nav-text">File System</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">14.1.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A6%82%E5%BF%B5"><span class="nav-number">14.2.</span> <span class="nav-text">文件概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89"><span class="nav-number">14.2.1.</span> <span class="nav-text">文件定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">14.2.2.</span> <span class="nav-text">文件属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.2.3.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">14.2.4.</span> <span class="nav-text">文件内部结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="nav-number">14.2.5.</span> <span class="nav-text">访问方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="nav-number">14.3.</span> <span class="nav-text">文件目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">14.3.1.</span> <span class="nav-text">目录结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">14.4.</span> <span class="nav-text">文件的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="nav-number">14.4.1.</span> <span class="nav-text">文件的打开与关闭</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="nav-number">14.5.</span> <span class="nav-text">共享与保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">14.5.1.</span> <span class="nav-text">文件访问控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#File-System-Implementation"><span class="nav-number">15.</span> <span class="nav-text">File-System Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#common-file-system"><span class="nav-number">15.1.</span> <span class="nav-text">common file system</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-1"><span class="nav-number">15.2.</span> <span class="nav-text">文件目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">15.3.</span> <span class="nav-text">访问方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE"><span class="nav-number">15.3.1.</span> <span class="nav-text">顺序访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="nav-number">15.3.2.</span> <span class="nav-text">直接访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="nav-number">15.4.</span> <span class="nav-text">分配方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%EF%BC%9A"><span class="nav-number">15.4.1.</span> <span class="nav-text">连续分配：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="nav-number">15.4.2.</span> <span class="nav-text">链接分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B0%87"><span class="nav-number">15.4.3.</span> <span class="nav-text">簇</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8FAT%EF%BC%88%E6%98%BE%E7%A4%BA%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="nav-number">15.4.4.</span> <span class="nav-text">文件分配表FAT（显示链接）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="nav-number">15.4.5.</span> <span class="nav-text">索引分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">15.5.</span> <span class="nav-text">空闲空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bit-Map"><span class="nav-number">15.5.1.</span> <span class="nav-text">Bit Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linked-List"><span class="nav-number">15.5.2.</span> <span class="nav-text">Linked List</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">15.6.</span> <span class="nav-text">文件系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#layered-file-system"><span class="nav-number">15.6.1.</span> <span class="nav-text">layered file system</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual-file-system"><span class="nav-number">15.6.2.</span> <span class="nav-text">virtual file system</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O-System"><span class="nav-number">16.</span> <span class="nav-text">I&#x2F;O System</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E7%A1%AC%E4%BB%B6"><span class="nav-number">16.1.</span> <span class="nav-text">I&#x2F;O硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B"><span class="nav-number">16.1.1.</span> <span class="nav-text">设备类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">16.1.2.</span> <span class="nav-text">控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E7%AB%AF%E5%8F%A3"><span class="nav-number">16.1.3.</span> <span class="nav-text">I&#x2F;O端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E5%9C%B0%E5%9D%80"><span class="nav-number">16.1.4.</span> <span class="nav-text">I&#x2F;O地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">16.1.5.</span> <span class="nav-text">I&#x2F;O控制方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8I-O%E7%BB%93%E6%9E%84"><span class="nav-number">16.2.</span> <span class="nav-text">内核I&#x2F;O结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E8%AF%B7%E6%B1%82%E5%91%A8%E6%9C%9F"><span class="nav-number">16.2.1.</span> <span class="nav-text">I&#x2F;O请求周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E7%AD%94%E9%A2%98"><span class="nav-number">17.</span> <span class="nav-text">简答题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">17.1.</span> <span class="nav-text">虚拟存储器的特点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.2.</span> <span class="nav-text">分时操作系统和实时操作系统的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="nav-number">17.3.</span> <span class="nav-text">简述多道程序设计技术？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">17.4.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.5.</span> <span class="nav-text">什么是进程，和程序的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99"><span class="nav-number">17.6.</span> <span class="nav-text">进程进入临界区的调度原则?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PCB"><span class="nav-number">17.7.</span> <span class="nav-text">PCB?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="nav-number">17.8.</span> <span class="nav-text">内存管理的功能？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%92%8C%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.9.</span> <span class="nav-text">页式存储管理和段式存储管理的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF%E7%9A%84%E7%9B%AE%E7%9A%84%EF%BC%9F"><span class="nav-number">17.10.</span> <span class="nav-text">缓冲技术的目的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E9%81%93%EF%BC%9F"><span class="nav-number">17.11.</span> <span class="nav-text">什么是通道？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E7%94%B1%E5%93%AA%E4%B8%89%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%9F"><span class="nav-number">17.12.</span> <span class="nav-text">磁盘访问时间由哪三部分组成？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-number">17.13.</span> <span class="nav-text">简述中断处理过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">17.14.</span> <span class="nav-text">用户级线程和系统级线程的优缺点</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">doovvv</p>
  <div class="site-description" itemprop="description">一切都没有意外，只是多了些波折</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/doovvv" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;doovvv" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zhangch523@mail2.sysu.edu.cn" title="E-Mail → zhangch523@mail2.sysu.edu.cn"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">doovvv</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'IeEMujBge2kAmKaLJDalYGMx-gzGzoHsz',
      appKey     : 'ZJGbpaRGRbziJ12K4CO5IvuI',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://ieemujbg.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
